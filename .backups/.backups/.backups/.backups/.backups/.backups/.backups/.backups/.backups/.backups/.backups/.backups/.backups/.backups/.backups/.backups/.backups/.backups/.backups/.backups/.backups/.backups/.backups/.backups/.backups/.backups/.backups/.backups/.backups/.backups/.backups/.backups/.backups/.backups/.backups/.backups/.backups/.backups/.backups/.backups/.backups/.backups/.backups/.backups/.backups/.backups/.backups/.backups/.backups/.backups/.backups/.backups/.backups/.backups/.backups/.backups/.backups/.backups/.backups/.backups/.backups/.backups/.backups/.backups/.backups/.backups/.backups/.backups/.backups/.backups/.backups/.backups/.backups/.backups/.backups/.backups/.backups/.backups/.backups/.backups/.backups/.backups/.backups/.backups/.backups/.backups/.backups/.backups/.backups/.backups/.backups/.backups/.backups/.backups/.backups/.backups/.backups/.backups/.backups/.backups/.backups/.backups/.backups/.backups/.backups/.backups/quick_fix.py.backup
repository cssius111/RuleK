#!/usr/bin/env python3
"""
RuleK 快速修复脚本
修复已知的具体问题
"""

import os
import re
from pathlib import Path
import shutil
from typing import List, Tuple

class QuickFixer:
    def __init__(self):
        self.project_root = Path.cwd()
        self.fixes_applied = []
        self.backup_dir = self.project_root / ".backups"
        
    def apply_quick_fixes(self):
        """应用快速修复"""
        print("⚡ RuleK 快速修复工具")
        print("=" * 50)
        
        # 创建备份目录
        self.backup_dir.mkdir(exist_ok=True)
        
        # 应用各种修复
        self.fix_turn_count_issue()
        self.fix_rules_access_issue()
        self.fix_pydantic_v2_syntax()
        self.fix_import_paths()
        self.fix_ai_specific_issues()
        
        # 显示结果
        self.show_results()
        
    def fix_turn_count_issue(self):
        """修复turn_count vs current_turn问题"""
        print("\n🔧 修复turn_count问题...")
        
        files_to_fix = [
            "src/ai/turn_pipeline.py",
            "src/core/game_state.py",
            "src/cli_game.py",
            "tests/**/*.py"
        ]
        
        pattern = r'\b(\w+\.)?turn_count\b'
        replacement = r'\1current_turn'
        
        for file_pattern in files_to_fix:
            for file_path in self.project_root.glob(file_pattern):
                if self.fix_in_file(file_path, pattern, replacement):
                    self.fixes_applied.append(f"修复turn_count: {file_path.relative_to(self.project_root)}")
                    
    def fix_rules_access_issue(self):
        """修复rules访问问题"""
        print("\n🔧 修复rules访问问题...")
        
        # 修复 self.game_mgr.state.rules
        pattern1 = r'self\.game_mgr\.state\.rules'
        replacement1 = 'self.game_mgr.rules'
        
        # 修复 game_mgr.state.rules
        pattern2 = r'game_mgr\.state\.rules'
        replacement2 = 'game_mgr.rules'
        
        # 修复 state.locations 访问
        pattern3 = r'self\.game_mgr\.state\.locations\b'
        replacement3 = 'list(self.game_mgr.state.locations.keys())'
        
        ai_files = list(self.project_root.glob("src/ai/*.py"))
        ai_files.extend(self.project_root.glob("src/core/*.py"))
        
        for file_path in ai_files:
            changed = False
            if self.fix_in_file(file_path, pattern1, replacement1):
                changed = True
            if self.fix_in_file(file_path, pattern2, replacement2):
                changed = True
            if self.fix_in_file(file_path, pattern3, replacement3):
                changed = True
                
            if changed:
                self.fixes_applied.append(f"修复rules访问: {file_path.relative_to(self.project_root)}")
                
    def fix_pydantic_v2_syntax(self):
        """修复Pydantic v2语法"""
        print("\n🔧 修复Pydantic v2语法...")
        
        replacements = [
            (r'from pydantic import validator\b', 'from pydantic import field_validator'),
            (r'@validator\b', '@field_validator'),
            (r'class Config:', 'model_config = ConfigDict('),
            (r'schema_extra', 'json_schema_extra'),
            (r'\.parse_obj\(', '.model_validate('),
            (r'\.dict\(\)', '.model_dump()'),
            (r'from pydantic import BaseModel\b', 'from pydantic import BaseModel, ConfigDict, field_validator'),
        ]
        
        model_files = list(self.project_root.glob("src/models/*.py"))
        model_files.extend(self.project_root.glob("src/api/*.py"))
        
        for file_path in model_files:
            changed = False
            for pattern, replacement in replacements:
                if self.fix_in_file(file_path, pattern, replacement):
                    changed = True
                    
            if changed:
                self.fixes_applied.append(f"更新Pydantic语法: {file_path.relative_to(self.project_root)}")
                
    def fix_import_paths(self):
        """修复导入路径"""
        print("\n🔧 修复导入路径...")
        
        # 修复常见的错误导入
        wrong_imports = [
            ('from src.api.deepseek_client', 'from src.api.deepseek_client'),
            ('from src.api.deepseek_client', 'from src.api.deepseek_client'),
            ('from core.game_state', 'from src.core.game_state'),
        ]
        
        for file_path in self.project_root.rglob("*.py"):
            if "venv" in str(file_path) or "__pycache__" in str(file_path):
                continue
                
            changed = False
            for wrong, correct in wrong_imports:
                if self.fix_in_file(file_path, wrong, correct):
                    changed = True
                    
            if changed:
                self.fixes_applied.append(f"修复导入路径: {file_path.relative_to(self.project_root)}")
                
    def fix_ai_specific_issues(self):
        """修复AI特定问题"""
        print("\n🔧 修复AI特定问题...")
        
        # 1. 在DeepSeekClient中添加Mock模式支持
        client_file = self.project_root / "src/api/deepseek_client.py"
        if client_file.exists():
            with open(client_file, 'r', encoding='utf-8') as f:
                content = f.read()
                
            # 检查是否需要添加Mock支持
            if "mock_mode" not in content:
                # 在类初始化中添加mock_mode检查
                mock_check = '''
        # Mock模式检查
        self.mock_mode = config.deepseek_api_key in ['mock', '', None]
        if self.mock_mode:
            logger.info("使用Mock模式")
'''
                # 查找__init__方法
                init_pattern = r'(def __init__\(self.*?\):\s*\n)'
                if re.search(init_pattern, content):
                    content = re.sub(
                        init_pattern,
                        r'\1' + mock_check,
                        content,
                        count=1
                    )
                    
                    self.backup_file(client_file)
                    with open(client_file, 'w', encoding='utf-8') as f:
                        f.write(content)
                    self.fixes_applied.append("添加Mock模式支持到DeepSeekClient")
                    
        # 2. 确保AI方法的异步别名存在
        self.ensure_async_aliases()
        
    def ensure_async_aliases(self):
        """确保异步方法别名存在"""
        client_file = self.project_root / "src/api/deepseek_client.py"
        if not client_file.exists():
            return
            
        with open(client_file, 'r', encoding='utf-8') as f:
            content = f.read()
            
        # 需要的别名
        aliases_needed = [
            ('evaluate_rule_async', 'evaluate_rule_nl'),
            ('generate_narrative_async', 'generate_narrative_text'),
            ('generate_npc_batch_async', 'generate_turn_plan'),
        ]
        
        additions = []
        for alias, original in aliases_needed:
            if f"def {alias}" not in content and f"def {original}" in content:
                additions.append(f"\n    # 别名方法\n    {alias} = {original}")
                
        if additions:
            # 在类的末尾添加别名
            class_end_pattern = r'(class DeepSeekClient:.*?)(\n\nclass|\n\nif __name__|$)'
            match = re.search(class_end_pattern, content, re.DOTALL)
            if match:
                insertion_point = match.end(1)
                new_content = content[:insertion_point] + ''.join(additions) + content[insertion_point:]
                
                self.backup_file(client_file)
                with open(client_file, 'w', encoding='utf-8') as f:
                    f.write(new_content)
                self.fixes_applied.append("添加异步方法别名")
                
    def fix_in_file(self, file_path: Path, pattern: str, replacement: str) -> bool:
        """在文件中应用修复"""
        if not file_path.exists() or file_path.is_dir():
            return False
            
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
                
            new_content = re.sub(pattern, replacement, content)
            
            if new_content != content:
                # 备份原文件
                self.backup_file(file_path)
                
                # 写入修复后的内容
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write(new_content)
                    
                return True
                
        except Exception as e:
            print(f"  ⚠️ 无法修复 {file_path}: {e}")
            
        return False
        
    def backup_file(self, file_path: Path):
        """备份文件"""
        relative_path = file_path.relative_to(self.project_root)
        backup_path = self.backup_dir / relative_path
        backup_path.parent.mkdir(parents=True, exist_ok=True)
        shutil.copy2(file_path, backup_path)
        
    def show_results(self):
        """显示结果"""
        print("\n" + "=" * 50)
        print("📊 修复结果")
        print("=" * 50)
        
        if self.fixes_applied:
            print(f"\n✅ 成功应用了 {len(self.fixes_applied)} 个修复:")
            for fix in self.fixes_applied:
                print(f"  - {fix}")
                
            print(f"\n💾 原文件已备份到: {self.backup_dir}")
            print("\n建议:")
            print("1. 运行测试验证修复: python auto_test_fix.py")
            print("2. 如需回滚，使用备份文件")
        else:
            print("\n✨ 没有发现需要修复的问题！")
            
        # 创建修复报告
        report_file = self.project_root / "quick_fix_report.txt"
        with open(report_file, 'w', encoding='utf-8') as f:
            f.write("RuleK 快速修复报告\n")
            f.write("=" * 50 + "\n\n")
            if self.fixes_applied:
                f.write(f"应用的修复 ({len(self.fixes_applied)}个):\n")
                for fix in self.fixes_applied:
                    f.write(f"- {fix}\n")
            else:
                f.write("没有需要修复的问题\n")
                
        print(f"\n📄 详细报告已保存到: quick_fix_report.txt")

if __name__ == "__main__":
    fixer = QuickFixer()
    fixer.apply_quick_fixes()
