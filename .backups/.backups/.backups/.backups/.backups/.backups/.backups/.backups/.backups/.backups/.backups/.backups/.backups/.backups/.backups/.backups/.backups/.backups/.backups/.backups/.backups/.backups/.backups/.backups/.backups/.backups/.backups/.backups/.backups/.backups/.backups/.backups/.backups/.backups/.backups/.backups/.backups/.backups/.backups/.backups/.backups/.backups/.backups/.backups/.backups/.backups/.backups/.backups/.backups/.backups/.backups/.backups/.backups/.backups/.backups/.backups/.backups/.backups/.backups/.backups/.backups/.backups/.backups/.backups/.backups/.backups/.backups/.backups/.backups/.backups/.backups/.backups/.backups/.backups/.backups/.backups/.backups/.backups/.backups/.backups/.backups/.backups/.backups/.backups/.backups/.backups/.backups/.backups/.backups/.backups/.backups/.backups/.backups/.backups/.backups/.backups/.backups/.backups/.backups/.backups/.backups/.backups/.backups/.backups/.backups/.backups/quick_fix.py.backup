#!/usr/bin/env python3
"""
RuleK å¿«é€Ÿä¿®å¤è„šæœ¬
ä¿®å¤å·²çŸ¥çš„å…·ä½“é—®é¢˜
"""

import os
import re
from pathlib import Path
import shutil
from typing import List, Tuple

class QuickFixer:
    def __init__(self):
        self.project_root = Path.cwd()
        self.fixes_applied = []
        self.backup_dir = self.project_root / ".backups"
        
    def apply_quick_fixes(self):
        """åº”ç”¨å¿«é€Ÿä¿®å¤"""
        print("âš¡ RuleK å¿«é€Ÿä¿®å¤å·¥å…·")
        print("=" * 50)
        
        # åˆ›å»ºå¤‡ä»½ç›®å½•
        self.backup_dir.mkdir(exist_ok=True)
        
        # åº”ç”¨å„ç§ä¿®å¤
        self.fix_turn_count_issue()
        self.fix_rules_access_issue()
        self.fix_pydantic_v2_syntax()
        self.fix_import_paths()
        self.fix_ai_specific_issues()
        
        # æ˜¾ç¤ºç»“æœ
        self.show_results()
        
    def fix_turn_count_issue(self):
        """ä¿®å¤turn_count vs current_turné—®é¢˜"""
        print("\nğŸ”§ ä¿®å¤turn_counté—®é¢˜...")
        
        files_to_fix = [
            "src/ai/turn_pipeline.py",
            "src/core/game_state.py",
            "src/cli_game.py",
            "tests/**/*.py"
        ]
        
        pattern = r'\b(\w+\.)?turn_count\b'
        replacement = r'\1current_turn'
        
        for file_pattern in files_to_fix:
            for file_path in self.project_root.glob(file_pattern):
                if self.fix_in_file(file_path, pattern, replacement):
                    self.fixes_applied.append(f"ä¿®å¤turn_count: {file_path.relative_to(self.project_root)}")
                    
    def fix_rules_access_issue(self):
        """ä¿®å¤rulesè®¿é—®é—®é¢˜"""
        print("\nğŸ”§ ä¿®å¤rulesè®¿é—®é—®é¢˜...")
        
        # ä¿®å¤ self.game_mgr.state.rules
        pattern1 = r'self\.game_mgr\.state\.rules'
        replacement1 = 'self.game_mgr.rules'
        
        # ä¿®å¤ game_mgr.state.rules
        pattern2 = r'game_mgr\.state\.rules'
        replacement2 = 'game_mgr.rules'
        
        # ä¿®å¤ state.locations è®¿é—®
        pattern3 = r'self\.game_mgr\.state\.locations\b'
        replacement3 = 'list(self.game_mgr.state.locations.keys())'
        
        ai_files = list(self.project_root.glob("src/ai/*.py"))
        ai_files.extend(self.project_root.glob("src/core/*.py"))
        
        for file_path in ai_files:
            changed = False
            if self.fix_in_file(file_path, pattern1, replacement1):
                changed = True
            if self.fix_in_file(file_path, pattern2, replacement2):
                changed = True
            if self.fix_in_file(file_path, pattern3, replacement3):
                changed = True
                
            if changed:
                self.fixes_applied.append(f"ä¿®å¤rulesè®¿é—®: {file_path.relative_to(self.project_root)}")
                
    def fix_pydantic_v2_syntax(self):
        """ä¿®å¤Pydantic v2è¯­æ³•"""
        print("\nğŸ”§ ä¿®å¤Pydantic v2è¯­æ³•...")
        
        replacements = [
            (r'from pydantic import validator\b', 'from pydantic import field_validator'),
            (r'@validator\b', '@field_validator'),
            (r'class Config:', 'model_config = ConfigDict('),
            (r'schema_extra', 'json_schema_extra'),
            (r'\.parse_obj\(', '.model_validate('),
            (r'\.dict\(\)', '.model_dump()'),
            (r'from pydantic import BaseModel\b', 'from pydantic import BaseModel, ConfigDict, field_validator'),
        ]
        
        model_files = list(self.project_root.glob("src/models/*.py"))
        model_files.extend(self.project_root.glob("src/api/*.py"))
        
        for file_path in model_files:
            changed = False
            for pattern, replacement in replacements:
                if self.fix_in_file(file_path, pattern, replacement):
                    changed = True
                    
            if changed:
                self.fixes_applied.append(f"æ›´æ–°Pydanticè¯­æ³•: {file_path.relative_to(self.project_root)}")
                
    def fix_import_paths(self):
        """ä¿®å¤å¯¼å…¥è·¯å¾„"""
        print("\nğŸ”§ ä¿®å¤å¯¼å…¥è·¯å¾„...")
        
        # ä¿®å¤å¸¸è§çš„é”™è¯¯å¯¼å…¥
        wrong_imports = [
            ('from src.api.deepseek_client', 'from src.api.deepseek_client'),
            ('from src.api.deepseek_client', 'from src.api.deepseek_client'),
            ('from core.game_state', 'from src.core.game_state'),
        ]
        
        for file_path in self.project_root.rglob("*.py"):
            if "venv" in str(file_path) or "__pycache__" in str(file_path):
                continue
                
            changed = False
            for wrong, correct in wrong_imports:
                if self.fix_in_file(file_path, wrong, correct):
                    changed = True
                    
            if changed:
                self.fixes_applied.append(f"ä¿®å¤å¯¼å…¥è·¯å¾„: {file_path.relative_to(self.project_root)}")
                
    def fix_ai_specific_issues(self):
        """ä¿®å¤AIç‰¹å®šé—®é¢˜"""
        print("\nğŸ”§ ä¿®å¤AIç‰¹å®šé—®é¢˜...")
        
        # 1. åœ¨DeepSeekClientä¸­æ·»åŠ Mockæ¨¡å¼æ”¯æŒ
        client_file = self.project_root / "src/api/deepseek_client.py"
        if client_file.exists():
            with open(client_file, 'r', encoding='utf-8') as f:
                content = f.read()
                
            # æ£€æŸ¥æ˜¯å¦éœ€è¦æ·»åŠ Mockæ”¯æŒ
            if "mock_mode" not in content:
                # åœ¨ç±»åˆå§‹åŒ–ä¸­æ·»åŠ mock_modeæ£€æŸ¥
                mock_check = '''
        # Mockæ¨¡å¼æ£€æŸ¥
        self.mock_mode = config.deepseek_api_key in ['mock', '', None]
        if self.mock_mode:
            logger.info("ä½¿ç”¨Mockæ¨¡å¼")
'''
                # æŸ¥æ‰¾__init__æ–¹æ³•
                init_pattern = r'(def __init__\(self.*?\):\s*\n)'
                if re.search(init_pattern, content):
                    content = re.sub(
                        init_pattern,
                        r'\1' + mock_check,
                        content,
                        count=1
                    )
                    
                    self.backup_file(client_file)
                    with open(client_file, 'w', encoding='utf-8') as f:
                        f.write(content)
                    self.fixes_applied.append("æ·»åŠ Mockæ¨¡å¼æ”¯æŒåˆ°DeepSeekClient")
                    
        # 2. ç¡®ä¿AIæ–¹æ³•çš„å¼‚æ­¥åˆ«åå­˜åœ¨
        self.ensure_async_aliases()
        
    def ensure_async_aliases(self):
        """ç¡®ä¿å¼‚æ­¥æ–¹æ³•åˆ«åå­˜åœ¨"""
        client_file = self.project_root / "src/api/deepseek_client.py"
        if not client_file.exists():
            return
            
        with open(client_file, 'r', encoding='utf-8') as f:
            content = f.read()
            
        # éœ€è¦çš„åˆ«å
        aliases_needed = [
            ('evaluate_rule_async', 'evaluate_rule_nl'),
            ('generate_narrative_async', 'generate_narrative_text'),
            ('generate_npc_batch_async', 'generate_turn_plan'),
        ]
        
        additions = []
        for alias, original in aliases_needed:
            if f"def {alias}" not in content and f"def {original}" in content:
                additions.append(f"\n    # åˆ«åæ–¹æ³•\n    {alias} = {original}")
                
        if additions:
            # åœ¨ç±»çš„æœ«å°¾æ·»åŠ åˆ«å
            class_end_pattern = r'(class DeepSeekClient:.*?)(\n\nclass|\n\nif __name__|$)'
            match = re.search(class_end_pattern, content, re.DOTALL)
            if match:
                insertion_point = match.end(1)
                new_content = content[:insertion_point] + ''.join(additions) + content[insertion_point:]
                
                self.backup_file(client_file)
                with open(client_file, 'w', encoding='utf-8') as f:
                    f.write(new_content)
                self.fixes_applied.append("æ·»åŠ å¼‚æ­¥æ–¹æ³•åˆ«å")
                
    def fix_in_file(self, file_path: Path, pattern: str, replacement: str) -> bool:
        """åœ¨æ–‡ä»¶ä¸­åº”ç”¨ä¿®å¤"""
        if not file_path.exists() or file_path.is_dir():
            return False
            
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
                
            new_content = re.sub(pattern, replacement, content)
            
            if new_content != content:
                # å¤‡ä»½åŸæ–‡ä»¶
                self.backup_file(file_path)
                
                # å†™å…¥ä¿®å¤åçš„å†…å®¹
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write(new_content)
                    
                return True
                
        except Exception as e:
            print(f"  âš ï¸ æ— æ³•ä¿®å¤ {file_path}: {e}")
            
        return False
        
    def backup_file(self, file_path: Path):
        """å¤‡ä»½æ–‡ä»¶"""
        relative_path = file_path.relative_to(self.project_root)
        backup_path = self.backup_dir / relative_path
        backup_path.parent.mkdir(parents=True, exist_ok=True)
        shutil.copy2(file_path, backup_path)
        
    def show_results(self):
        """æ˜¾ç¤ºç»“æœ"""
        print("\n" + "=" * 50)
        print("ğŸ“Š ä¿®å¤ç»“æœ")
        print("=" * 50)
        
        if self.fixes_applied:
            print(f"\nâœ… æˆåŠŸåº”ç”¨äº† {len(self.fixes_applied)} ä¸ªä¿®å¤:")
            for fix in self.fixes_applied:
                print(f"  - {fix}")
                
            print(f"\nğŸ’¾ åŸæ–‡ä»¶å·²å¤‡ä»½åˆ°: {self.backup_dir}")
            print("\nå»ºè®®:")
            print("1. è¿è¡Œæµ‹è¯•éªŒè¯ä¿®å¤: python auto_test_fix.py")
            print("2. å¦‚éœ€å›æ»šï¼Œä½¿ç”¨å¤‡ä»½æ–‡ä»¶")
        else:
            print("\nâœ¨ æ²¡æœ‰å‘ç°éœ€è¦ä¿®å¤çš„é—®é¢˜ï¼")
            
        # åˆ›å»ºä¿®å¤æŠ¥å‘Š
        report_file = self.project_root / "quick_fix_report.txt"
        with open(report_file, 'w', encoding='utf-8') as f:
            f.write("RuleK å¿«é€Ÿä¿®å¤æŠ¥å‘Š\n")
            f.write("=" * 50 + "\n\n")
            if self.fixes_applied:
                f.write(f"åº”ç”¨çš„ä¿®å¤ ({len(self.fixes_applied)}ä¸ª):\n")
                for fix in self.fixes_applied:
                    f.write(f"- {fix}\n")
            else:
                f.write("æ²¡æœ‰éœ€è¦ä¿®å¤çš„é—®é¢˜\n")
                
        print(f"\nğŸ“„ è¯¦ç»†æŠ¥å‘Šå·²ä¿å­˜åˆ°: quick_fix_report.txt")

if __name__ == "__main__":
    fixer = QuickFixer()
    fixer.apply_quick_fixes()
