#!/usr/bin/env python3
"""
RuleK æ™ºèƒ½è°ƒè¯•è¯Šæ–­å·¥å…·
è‡ªåŠ¨æ£€æµ‹å’Œä¿®å¤å¸¸è§é—®é¢˜
"""

import os
import sys
import json
import subprocess
import traceback
from pathlib import Path
from typing import Dict, List, Tuple, Optional
import importlib.util
import datetime

class RuleKDebugger:
    def __init__(self):
        self.project_root = Path.cwd()
        self.issues = []
        self.fixes_applied = []
        
    def run_full_diagnosis(self):
        """è¿è¡Œå®Œæ•´è¯Šæ–­"""
        print("ğŸ” RuleK æ™ºèƒ½è¯Šæ–­å·¥å…·")
        print("=" * 50)
        
        # 1. ç¯å¢ƒæ£€æŸ¥
        self.check_environment()
        
        # 2. ä¾èµ–æ£€æŸ¥
        self.check_dependencies()
        
        # 3. é…ç½®æ£€æŸ¥
        self.check_configuration()
        
        # 4. ä»£ç å¥åº·æ£€æŸ¥
        self.check_code_health()
        
        # 5. AIåŠŸèƒ½æ£€æŸ¥
        self.check_ai_functionality()
        
        # 6. æµ‹è¯•å¥—ä»¶æ£€æŸ¥
        self.check_test_suite()
        
        # 7. ç”ŸæˆæŠ¥å‘Š
        self.generate_report()
        
    def check_environment(self):
        """æ£€æŸ¥Pythonç¯å¢ƒ"""
        print("\nğŸ“¦ æ£€æŸ¥Pythonç¯å¢ƒ...")
        
        # Pythonç‰ˆæœ¬
        py_version = sys.version_info
        if py_version.major < 3 or (py_version.major == 3 and py_version.minor < 8):
            self.issues.append({
                "type": "ç¯å¢ƒ",
                "severity": "é«˜",
                "issue": f"Pythonç‰ˆæœ¬è¿‡ä½: {sys.version}",
                "fix": "å‡çº§åˆ°Python 3.8+"
            })
        else:
            print(f"âœ… Pythonç‰ˆæœ¬: {sys.version.split()[0]}")
            
        # æ£€æŸ¥è™šæ‹Ÿç¯å¢ƒ
        if not hasattr(sys, 'real_prefix') and not (hasattr(sys, 'base_prefix') and sys.base_prefix != sys.prefix):
            self.issues.append({
                "type": "ç¯å¢ƒ",
                "severity": "ä¸­",
                "issue": "æœªä½¿ç”¨è™šæ‹Ÿç¯å¢ƒ",
                "fix": "å»ºè®®ä½¿ç”¨è™šæ‹Ÿç¯å¢ƒ: python -m venv venv"
            })
        else:
            print("âœ… ä½¿ç”¨è™šæ‹Ÿç¯å¢ƒ")
            
        # æ£€æŸ¥PYTHONPATH
        if str(self.project_root) not in sys.path:
            sys.path.insert(0, str(self.project_root))
            print(f"âœ… å·²æ·»åŠ é¡¹ç›®æ ¹ç›®å½•åˆ°PYTHONPATH")
            
    def check_dependencies(self):
        """æ£€æŸ¥ä¾èµ–åŒ…"""
        print("\nğŸ“š æ£€æŸ¥ä¾èµ–åŒ…...")
        
        requirements_file = self.project_root / "requirements.txt"
        if not requirements_file.exists():
            self.issues.append({
                "type": "ä¾èµ–",
                "severity": "é«˜",
                "issue": "ç¼ºå°‘requirements.txt",
                "fix": "åˆ›å»ºrequirements.txtæ–‡ä»¶"
            })
            return
            
        # æ£€æŸ¥å·²å®‰è£…çš„åŒ…
        try:
            result = subprocess.run(
                [sys.executable, "-m", "pip", "freeze"],
                capture_output=True, text=True
            )
            installed_packages = {line.split('==')[0].lower() for line in result.stdout.strip().split('\n') if line}
            
            # è¯»å–requirements
            with open(requirements_file, 'r') as f:
                required_packages = set()
                for line in f:
                    line = line.strip()
                    if line and not line.startswith('#'):
                        pkg = line.split('==')[0].split('>=')[0].split('~=')[0].lower()
                        required_packages.add(pkg)
                        
            # æ‰¾å‡ºç¼ºå¤±çš„åŒ…
            missing = required_packages - installed_packages
            if missing:
                self.issues.append({
                    "type": "ä¾èµ–",
                    "severity": "é«˜",
                    "issue": f"ç¼ºå¤±ä¾èµ–åŒ…: {', '.join(missing)}",
                    "fix": "è¿è¡Œ: pip install -r requirements.txt"
                })
            else:
                print(f"âœ… æ‰€æœ‰ä¾èµ–åŒ…å·²å®‰è£… ({len(required_packages)}ä¸ª)")
                
        except Exception as e:
            self.issues.append({
                "type": "ä¾èµ–",
                "severity": "é«˜",
                "issue": f"æ£€æŸ¥ä¾èµ–å¤±è´¥: {str(e)}",
                "fix": "æ‰‹åŠ¨æ£€æŸ¥pipå’Œrequirements.txt"
            })
            
    def check_configuration(self):
        """æ£€æŸ¥é…ç½®æ–‡ä»¶"""
        print("\nâš™ï¸ æ£€æŸ¥é…ç½®æ–‡ä»¶...")
        
        # æ£€æŸ¥.envæ–‡ä»¶
        env_file = self.project_root / ".env"
        env_example = self.project_root / ".env.example"
        
        if not env_file.exists():
            if env_example.exists():
                self.issues.append({
                    "type": "é…ç½®",
                    "severity": "é«˜",
                    "issue": "ç¼ºå°‘.envæ–‡ä»¶",
                    "fix": "è¿è¡Œ: cp .env.example .env"
                })
            else:
                self.issues.append({
                    "type": "é…ç½®",
                    "severity": "é«˜",
                    "issue": "ç¼ºå°‘.envå’Œ.env.exampleæ–‡ä»¶",
                    "fix": "åˆ›å»º.envæ–‡ä»¶å¹¶æ·»åŠ DEEPSEEK_API_KEY"
                })
        else:
            # æ£€æŸ¥å…³é”®é…ç½®
            with open(env_file, 'r') as f:
                env_content = f.read()
                if 'DEEPSEEK_API_KEY' not in env_content:
                    self.issues.append({
                        "type": "é…ç½®",
                        "severity": "ä¸­",
                        "issue": ".envä¸­ç¼ºå°‘DEEPSEEK_API_KEY",
                        "fix": "åœ¨.envä¸­æ·»åŠ : DEEPSEEK_API_KEY=your_key_here"
                    })
                elif 'DEEPSEEK_API_KEY=""' in env_content or 'DEEPSEEK_API_KEY=' in env_content.strip():
                    self.issues.append({
                        "type": "é…ç½®", 
                        "severity": "ä¸­",
                        "issue": "DEEPSEEK_API_KEYä¸ºç©º",
                        "fix": "è®¾ç½®æœ‰æ•ˆçš„APIå¯†é’¥æˆ–ä½¿ç”¨Mockæ¨¡å¼"
                    })
                else:
                    print("âœ… .envé…ç½®æ–‡ä»¶å­˜åœ¨")
                    
        # æ£€æŸ¥config.json
        config_file = self.project_root / "config" / "config.json"
        if not config_file.exists():
            self.issues.append({
                "type": "é…ç½®",
                "severity": "é«˜",
                "issue": "ç¼ºå°‘config/config.json",
                "fix": "åˆ›å»ºé…ç½®æ–‡ä»¶æˆ–ä»æ¨¡æ¿å¤åˆ¶"
            })
        else:
            try:
                with open(config_file, 'r') as f:
                    config = json.load(f)
                    if not config.get('game', {}).get('ai_enabled'):
                        print("âš ï¸  AIåŠŸèƒ½æœªå¯ç”¨ (config.json)")
                    else:
                        print("âœ… config.jsoné…ç½®æ­£ç¡®")
            except json.JSONDecodeError:
                self.issues.append({
                    "type": "é…ç½®",
                    "severity": "é«˜",
                    "issue": "config.jsonæ ¼å¼é”™è¯¯",
                    "fix": "æ£€æŸ¥JSONæ ¼å¼æ˜¯å¦æ­£ç¡®"
                })
                
    def check_code_health(self):
        """æ£€æŸ¥ä»£ç å¥åº·åº¦"""
        print("\nğŸ¥ æ£€æŸ¥ä»£ç å¥åº·åº¦...")
        
        critical_files = [
            ("src/__init__.py", "åŒ…åˆå§‹åŒ–æ–‡ä»¶"),
            ("src/core/game_state.py", "æ¸¸æˆçŠ¶æ€ç®¡ç†"),
            ("src/cli_game.py", "CLIæ¸¸æˆä¸»ç¨‹åº"),
            ("src/api/deepseek_client.py", "AIå®¢æˆ·ç«¯"),
            ("src/ai/turn_pipeline.py", "AIå›åˆç®¡çº¿"),
        ]
        
        for file_path, description in critical_files:
            full_path = self.project_root / file_path
            if not full_path.exists():
                self.issues.append({
                    "type": "ä»£ç ",
                    "severity": "é«˜",
                    "issue": f"ç¼ºå°‘å…³é”®æ–‡ä»¶: {file_path}",
                    "fix": f"åˆ›å»º{description}æ–‡ä»¶"
                })
            else:
                # æ£€æŸ¥å¯¼å…¥
                try:
                    with open(full_path, 'r', encoding='utf-8') as f:
                        content = f.read()
                        
                    # æ£€æŸ¥å¸¸è§é—®é¢˜
                    if file_path == "src/ai/turn_pipeline.py":
                        if "self.game_mgr.state.rules" in content:
                            self.issues.append({
                                "type": "ä»£ç ",
                                "severity": "é«˜",
                                "issue": f"{file_path}ä¸­ä½¿ç”¨äº†é”™è¯¯çš„å±æ€§è®¿é—®",
                                "fix": "å°†self.game_mgr.state.rulesæ”¹ä¸ºself.game_mgr.rules"
                            })
                            
                    # æ£€æŸ¥Pydantic v1è¯­æ³•
                    if "@validator" in content and "pydantic" in content:
                        self.issues.append({
                            "type": "ä»£ç ",
                            "severity": "ä¸­",
                            "issue": f"{file_path}ä½¿ç”¨äº†Pydantic v1è¯­æ³•",
                            "fix": "æ›´æ–°ä¸ºPydantic v2è¯­æ³•(@field_validator)"
                        })
                        
                except Exception as e:
                    self.issues.append({
                        "type": "ä»£ç ",
                        "severity": "ä¸­",
                        "issue": f"æ— æ³•è¯»å–{file_path}: {str(e)}",
                        "fix": "æ£€æŸ¥æ–‡ä»¶æƒé™å’Œç¼–ç "
                    })
                    
        if not any(issue["type"] == "ä»£ç " and issue["severity"] == "é«˜" for issue in self.issues):
            print("âœ… å…³é”®ä»£ç æ–‡ä»¶å®Œæ•´")
            
    def check_ai_functionality(self):
        """æ£€æŸ¥AIåŠŸèƒ½"""
        print("\nğŸ¤– æ£€æŸ¥AIåŠŸèƒ½...")
        
        try:
            # å°è¯•å¯¼å…¥AIæ¨¡å—
            from src.api.deepseek_client import DeepSeekClient
            from src.api.schemas import TurnPlan
            from src.ai.turn_pipeline import AITurnPipeline
            print("âœ… AIæ¨¡å—å¯ä»¥å¯¼å…¥")
            
            # æ£€æŸ¥Mockæ¨¡å¼
            if os.getenv('DEEPSEEK_API_KEY', '').strip() == '':
                print("â„¹ï¸  å°†ä½¿ç”¨Mockæ¨¡å¼ï¼ˆæ— APIå¯†é’¥ï¼‰")
                
        except ImportError as e:
            self.issues.append({
                "type": "AI",
                "severity": "é«˜",
                "issue": f"AIæ¨¡å—å¯¼å…¥å¤±è´¥: {str(e)}",
                "fix": "æ£€æŸ¥AIç›¸å…³æ–‡ä»¶æ˜¯å¦å­˜åœ¨ä¸”è·¯å¾„æ­£ç¡®"
            })
            
    def check_test_suite(self):
        """æ£€æŸ¥æµ‹è¯•å¥—ä»¶"""
        print("\nğŸ§ª æ£€æŸ¥æµ‹è¯•å¥—ä»¶...")
        
        # æ£€æŸ¥pytestæ˜¯å¦å®‰è£…
        try:
            import pytest
            print("âœ… pytestå·²å®‰è£…")
        except ImportError:
            self.issues.append({
                "type": "æµ‹è¯•",
                "severity": "é«˜",
                "issue": "pytestæœªå®‰è£…",
                "fix": "è¿è¡Œ: pip install pytest pytest-asyncio"
            })
            return
            
        # æ£€æŸ¥æµ‹è¯•æ–‡ä»¶
        test_dirs = ["tests/unit", "tests/integration", "tests/api"]
        test_count = 0
        
        for test_dir in test_dirs:
            test_path = self.project_root / test_dir
            if test_path.exists():
                test_files = list(test_path.glob("test_*.py"))
                test_count += len(test_files)
                
        if test_count == 0:
            self.issues.append({
                "type": "æµ‹è¯•",
                "severity": "ä¸­",
                "issue": "æ²¡æœ‰æ‰¾åˆ°æµ‹è¯•æ–‡ä»¶",
                "fix": "åˆ›å»ºæµ‹è¯•æ–‡ä»¶æˆ–æ£€æŸ¥æµ‹è¯•ç›®å½•ç»“æ„"
            })
        else:
            print(f"âœ… æ‰¾åˆ°{test_count}ä¸ªæµ‹è¯•æ–‡ä»¶")
            
    def generate_report(self):
        """ç”Ÿæˆè¯Šæ–­æŠ¥å‘Š"""
        print("\n" + "=" * 50)
        print("ğŸ“Š è¯Šæ–­æŠ¥å‘Š")
        print("=" * 50)
        
        if not self.issues:
            print("\nâœ… æ²¡æœ‰å‘ç°é—®é¢˜ï¼é¡¹ç›®çŠ¶æ€è‰¯å¥½ã€‚")
            print("\nå»ºè®®è¿è¡Œ:")
            print("  python rulek.py test  # è¿è¡Œæµ‹è¯•")
            print("  python rulek.py cli   # å¯åŠ¨æ¸¸æˆ")
        else:
            # æŒ‰ä¸¥é‡ç¨‹åº¦åˆ†ç»„
            high_issues = [i for i in self.issues if i["severity"] == "é«˜"]
            medium_issues = [i for i in self.issues if i["severity"] == "ä¸­"]
            low_issues = [i for i in self.issues if i["severity"] == "ä½"]
            
            if high_issues:
                print(f"\nğŸ”´ ä¸¥é‡é—®é¢˜ ({len(high_issues)}ä¸ª):")
                for issue in high_issues:
                    print(f"  [{issue['type']}] {issue['issue']}")
                    print(f"     ä¿®å¤: {issue['fix']}")
                    
            if medium_issues:
                print(f"\nğŸŸ¡ ä¸­ç­‰é—®é¢˜ ({len(medium_issues)}ä¸ª):")
                for issue in medium_issues:
                    print(f"  [{issue['type']}] {issue['issue']}")
                    print(f"     ä¿®å¤: {issue['fix']}")
                    
            if low_issues:
                print(f"\nğŸŸ¢ è½»å¾®é—®é¢˜ ({len(low_issues)}ä¸ª):")
                for issue in low_issues:
                    print(f"  [{issue['type']}] {issue['issue']}")
                    print(f"     ä¿®å¤: {issue['fix']}")
                    
            # ç”Ÿæˆä¿®å¤è„šæœ¬
            self.generate_fix_script()
            
    def generate_fix_script(self):
        """ç”Ÿæˆè‡ªåŠ¨ä¿®å¤è„šæœ¬"""
        print("\nğŸ“ ç”Ÿæˆä¿®å¤å»ºè®®...")
        
        fix_commands = []
        
        for issue in self.issues:
            if issue["severity"] == "é«˜":
                if "pip install" in issue["fix"]:
                    fix_commands.append(issue["fix"])
                elif "cp .env.example .env" in issue["fix"]:
                    fix_commands.append(issue["fix"])
                    
        if fix_commands:
            print("\nå¯ä»¥è¿è¡Œä»¥ä¸‹å‘½ä»¤ä¿®å¤éƒ¨åˆ†é—®é¢˜:")
            for cmd in fix_commands:
                print(f"  {cmd}")
                
        # ä¿å­˜è¯¦ç»†æŠ¥å‘Š
        report_file = self.project_root / "debug_report.md"
        with open(report_file, 'w', encoding='utf-8') as f:
            f.write("# RuleK è¯Šæ–­æŠ¥å‘Š\n\n")
            f.write(f"ç”Ÿæˆæ—¶é—´: {datetime.datetime.now()}\n\n")
            
            f.write("## å‘ç°çš„é—®é¢˜\n\n")
            for i, issue in enumerate(self.issues, 1):
                f.write(f"### {i}. [{issue['severity']}] {issue['type']} - {issue['issue']}\n")
                f.write(f"**ä¿®å¤æ–¹æ³•**: {issue['fix']}\n\n")
                
        print(f"\nè¯¦ç»†æŠ¥å‘Šå·²ä¿å­˜åˆ°: debug_report.md")

if __name__ == "__main__":
    debugger = RuleKDebugger()
    debugger.run_full_diagnosis()
