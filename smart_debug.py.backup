#!/usr/bin/env python3
"""
RuleK 智能调试诊断工具
自动检测和修复常见问题
"""

import os
import sys
import json
import subprocess
import traceback
from pathlib import Path
from typing import Dict, List, Tuple, Optional
import importlib.util
import datetime

class RuleKDebugger:
    def __init__(self):
        self.project_root = Path.cwd()
        self.issues = []
        self.fixes_applied = []
        
    def run_full_diagnosis(self):
        """运行完整诊断"""
        print("🔍 RuleK 智能诊断工具")
        print("=" * 50)
        
        # 1. 环境检查
        self.check_environment()
        
        # 2. 依赖检查
        self.check_dependencies()
        
        # 3. 配置检查
        self.check_configuration()
        
        # 4. 代码健康检查
        self.check_code_health()
        
        # 5. AI功能检查
        self.check_ai_functionality()
        
        # 6. 测试套件检查
        self.check_test_suite()
        
        # 7. 生成报告
        self.generate_report()
        
    def check_environment(self):
        """检查Python环境"""
        print("\n📦 检查Python环境...")
        
        # Python版本
        py_version = sys.version_info
        if py_version.major < 3 or (py_version.major == 3 and py_version.minor < 8):
            self.issues.append({
                "type": "环境",
                "severity": "高",
                "issue": f"Python版本过低: {sys.version}",
                "fix": "升级到Python 3.8+"
            })
        else:
            print(f"✅ Python版本: {sys.version.split()[0]}")
            
        # 检查虚拟环境
        if not hasattr(sys, 'real_prefix') and not (hasattr(sys, 'base_prefix') and sys.base_prefix != sys.prefix):
            self.issues.append({
                "type": "环境",
                "severity": "中",
                "issue": "未使用虚拟环境",
                "fix": "建议使用虚拟环境: python -m venv venv"
            })
        else:
            print("✅ 使用虚拟环境")
            
        # 检查PYTHONPATH
        if str(self.project_root) not in sys.path:
            sys.path.insert(0, str(self.project_root))
            print(f"✅ 已添加项目根目录到PYTHONPATH")
            
    def check_dependencies(self):
        """检查依赖包"""
        print("\n📚 检查依赖包...")
        
        requirements_file = self.project_root / "requirements.txt"
        if not requirements_file.exists():
            self.issues.append({
                "type": "依赖",
                "severity": "高",
                "issue": "缺少requirements.txt",
                "fix": "创建requirements.txt文件"
            })
            return
            
        # 检查已安装的包
        try:
            result = subprocess.run(
                [sys.executable, "-m", "pip", "freeze"],
                capture_output=True, text=True
            )
            installed_packages = {line.split('==')[0].lower() for line in result.stdout.strip().split('\n') if line}
            
            # 读取requirements
            with open(requirements_file, 'r') as f:
                required_packages = set()
                for line in f:
                    line = line.strip()
                    if line and not line.startswith('#'):
                        pkg = line.split('==')[0].split('>=')[0].split('~=')[0].lower()
                        required_packages.add(pkg)
                        
            # 找出缺失的包
            missing = required_packages - installed_packages
            if missing:
                self.issues.append({
                    "type": "依赖",
                    "severity": "高",
                    "issue": f"缺失依赖包: {', '.join(missing)}",
                    "fix": "运行: pip install -r requirements.txt"
                })
            else:
                print(f"✅ 所有依赖包已安装 ({len(required_packages)}个)")
                
        except Exception as e:
            self.issues.append({
                "type": "依赖",
                "severity": "高",
                "issue": f"检查依赖失败: {str(e)}",
                "fix": "手动检查pip和requirements.txt"
            })
            
    def check_configuration(self):
        """检查配置文件"""
        print("\n⚙️ 检查配置文件...")
        
        # 检查.env文件
        env_file = self.project_root / ".env"
        env_example = self.project_root / ".env.example"
        
        if not env_file.exists():
            if env_example.exists():
                self.issues.append({
                    "type": "配置",
                    "severity": "高",
                    "issue": "缺少.env文件",
                    "fix": "运行: cp .env.example .env"
                })
            else:
                self.issues.append({
                    "type": "配置",
                    "severity": "高",
                    "issue": "缺少.env和.env.example文件",
                    "fix": "创建.env文件并添加DEEPSEEK_API_KEY"
                })
        else:
            # 检查关键配置
            with open(env_file, 'r') as f:
                env_content = f.read()
                if 'DEEPSEEK_API_KEY' not in env_content:
                    self.issues.append({
                        "type": "配置",
                        "severity": "中",
                        "issue": ".env中缺少DEEPSEEK_API_KEY",
                        "fix": "在.env中添加: DEEPSEEK_API_KEY=your_key_here"
                    })
                elif 'DEEPSEEK_API_KEY=""' in env_content or 'DEEPSEEK_API_KEY=' in env_content.strip():
                    self.issues.append({
                        "type": "配置", 
                        "severity": "中",
                        "issue": "DEEPSEEK_API_KEY为空",
                        "fix": "设置有效的API密钥或使用Mock模式"
                    })
                else:
                    print("✅ .env配置文件存在")
                    
        # 检查config.json
        config_file = self.project_root / "config" / "config.json"
        if not config_file.exists():
            self.issues.append({
                "type": "配置",
                "severity": "高",
                "issue": "缺少config/config.json",
                "fix": "创建配置文件或从模板复制"
            })
        else:
            try:
                with open(config_file, 'r') as f:
                    config = json.load(f)
                    if not config.get('game', {}).get('ai_enabled'):
                        print("⚠️  AI功能未启用 (config.json)")
                    else:
                        print("✅ config.json配置正确")
            except json.JSONDecodeError:
                self.issues.append({
                    "type": "配置",
                    "severity": "高",
                    "issue": "config.json格式错误",
                    "fix": "检查JSON格式是否正确"
                })
                
    def check_code_health(self):
        """检查代码健康度"""
        print("\n🏥 检查代码健康度...")
        
        critical_files = [
            ("src/__init__.py", "包初始化文件"),
            ("src/core/game_state.py", "游戏状态管理"),
            ("src/cli_game.py", "CLI游戏主程序"),
            ("src/api/deepseek_client.py", "AI客户端"),
            ("src/ai/turn_pipeline.py", "AI回合管线"),
        ]
        
        for file_path, description in critical_files:
            full_path = self.project_root / file_path
            if not full_path.exists():
                self.issues.append({
                    "type": "代码",
                    "severity": "高",
                    "issue": f"缺少关键文件: {file_path}",
                    "fix": f"创建{description}文件"
                })
            else:
                # 检查导入
                try:
                    with open(full_path, 'r', encoding='utf-8') as f:
                        content = f.read()
                        
                    # 检查常见问题
                    if file_path == "src/ai/turn_pipeline.py":
                        if "self.game_mgr.state.rules" in content:
                            self.issues.append({
                                "type": "代码",
                                "severity": "高",
                                "issue": f"{file_path}中使用了错误的属性访问",
                                "fix": "将self.game_mgr.state.rules改为self.game_mgr.rules"
                            })
                            
                    # 检查Pydantic v1语法
                    if "@validator" in content and "pydantic" in content:
                        self.issues.append({
                            "type": "代码",
                            "severity": "中",
                            "issue": f"{file_path}使用了Pydantic v1语法",
                            "fix": "更新为Pydantic v2语法(@field_validator)"
                        })
                        
                except Exception as e:
                    self.issues.append({
                        "type": "代码",
                        "severity": "中",
                        "issue": f"无法读取{file_path}: {str(e)}",
                        "fix": "检查文件权限和编码"
                    })
                    
        if not any(issue["type"] == "代码" and issue["severity"] == "高" for issue in self.issues):
            print("✅ 关键代码文件完整")
            
    def check_ai_functionality(self):
        """检查AI功能"""
        print("\n🤖 检查AI功能...")
        
        try:
            # 尝试导入AI模块
            from src.api.deepseek_client import DeepSeekClient
            from src.api.schemas import TurnPlan
            from src.ai.turn_pipeline import AITurnPipeline
            print("✅ AI模块可以导入")
            
            # 检查Mock模式
            if os.getenv('DEEPSEEK_API_KEY', '').strip() == '':
                print("ℹ️  将使用Mock模式（无API密钥）")
                
        except ImportError as e:
            self.issues.append({
                "type": "AI",
                "severity": "高",
                "issue": f"AI模块导入失败: {str(e)}",
                "fix": "检查AI相关文件是否存在且路径正确"
            })
            
    def check_test_suite(self):
        """检查测试套件"""
        print("\n🧪 检查测试套件...")
        
        # 检查pytest是否安装
        try:
            import pytest
            print("✅ pytest已安装")
        except ImportError:
            self.issues.append({
                "type": "测试",
                "severity": "高",
                "issue": "pytest未安装",
                "fix": "运行: pip install pytest pytest-asyncio"
            })
            return
            
        # 检查测试文件
        test_dirs = ["tests/unit", "tests/integration", "tests/api"]
        test_count = 0
        
        for test_dir in test_dirs:
            test_path = self.project_root / test_dir
            if test_path.exists():
                test_files = list(test_path.glob("test_*.py"))
                test_count += len(test_files)
                
        if test_count == 0:
            self.issues.append({
                "type": "测试",
                "severity": "中",
                "issue": "没有找到测试文件",
                "fix": "创建测试文件或检查测试目录结构"
            })
        else:
            print(f"✅ 找到{test_count}个测试文件")
            
    def generate_report(self):
        """生成诊断报告"""
        print("\n" + "=" * 50)
        print("📊 诊断报告")
        print("=" * 50)
        
        if not self.issues:
            print("\n✅ 没有发现问题！项目状态良好。")
            print("\n建议运行:")
            print("  python rulek.py test  # 运行测试")
            print("  python rulek.py cli   # 启动游戏")
        else:
            # 按严重程度分组
            high_issues = [i for i in self.issues if i["severity"] == "高"]
            medium_issues = [i for i in self.issues if i["severity"] == "中"]
            low_issues = [i for i in self.issues if i["severity"] == "低"]
            
            if high_issues:
                print(f"\n🔴 严重问题 ({len(high_issues)}个):")
                for issue in high_issues:
                    print(f"  [{issue['type']}] {issue['issue']}")
                    print(f"     修复: {issue['fix']}")
                    
            if medium_issues:
                print(f"\n🟡 中等问题 ({len(medium_issues)}个):")
                for issue in medium_issues:
                    print(f"  [{issue['type']}] {issue['issue']}")
                    print(f"     修复: {issue['fix']}")
                    
            if low_issues:
                print(f"\n🟢 轻微问题 ({len(low_issues)}个):")
                for issue in low_issues:
                    print(f"  [{issue['type']}] {issue['issue']}")
                    print(f"     修复: {issue['fix']}")
                    
            # 生成修复脚本
            self.generate_fix_script()
            
    def generate_fix_script(self):
        """生成自动修复脚本"""
        print("\n📝 生成修复建议...")
        
        fix_commands = []
        
        for issue in self.issues:
            if issue["severity"] == "高":
                if "pip install" in issue["fix"]:
                    fix_commands.append(issue["fix"])
                elif "cp .env.example .env" in issue["fix"]:
                    fix_commands.append(issue["fix"])
                    
        if fix_commands:
            print("\n可以运行以下命令修复部分问题:")
            for cmd in fix_commands:
                print(f"  {cmd}")
                
        # 保存详细报告
        report_file = self.project_root / "debug_report.md"
        with open(report_file, 'w', encoding='utf-8') as f:
            f.write("# RuleK 诊断报告\n\n")
            f.write(f"生成时间: {datetime.datetime.now()}\n\n")
            
            f.write("## 发现的问题\n\n")
            for i, issue in enumerate(self.issues, 1):
                f.write(f"### {i}. [{issue['severity']}] {issue['type']} - {issue['issue']}\n")
                f.write(f"**修复方法**: {issue['fix']}\n\n")
                
        print(f"\n详细报告已保存到: debug_report.md")

if __name__ == "__main__":
    debugger = RuleKDebugger()
    debugger.run_full_diagnosis()
